import {databases, db} from './appwrite';
import { UserSchema, UserRegistrationSchema, StorySchema, StoryNodeSchema } from '../src/schemas'
import type { User, Story, StoryNode } from "../types/"

import {ID, Query } from 'react-native-appwrite'

// Service class wrapping all database operations
export class DatabaseService{
    async createUser(userData: Omit<User, 'id'>, userId?: string): Promise <User>{
        try{
            // Ensure we have a valid ID
            const finalUserId = userId || ID.unique();
            console.log('Creating user with ID:', finalUserId);
            
            // Add autogenerated fields
            const validatedData = UserSchema.parse({
                ...userData,
                id: finalUserId,
            })
            
            // Check if user already exists to prevent duplicates
            try {
                const existingUser = await this.getUserById(validatedData.id);
                if (existingUser) {
                    console.log('User already exists with ID:', validatedData.id);
                    return existingUser;
                }
            } catch (error: any) {
                // User doesn't exist, continue with creation
                if (error.code !== 404) {
                    console.warn('Unexpected error checking for existing user:', error);
                }
            }
            
            // Prepare document data without the 'id' field (Appwrite handles ID separately)
            const { id, ...documentData } = validatedData;
            
            // Insert into Appwrite Users collection
            const response = await databases.createDocument(
                db.databaseId,
                db.collections.USERS,
                id, // Use ID as document ID parameter
                documentData, // Document data without the ID field
            )
            
            console.log('Successfully created user in database:', id);
            return UserSchema.parse(response);
        }catch(error: any){
            console.error('Database createUser error:', error);
            
            // Provide more specific error messages
            if (error.code === 409) {
                throw new Error(`User with this ID already exists: ${userData.id}`);
            } else if (error.code === 400) {
                throw new Error(`Invalid user data provided: ${error.message}`);
            } else {
                throw new Error(`Failed to create user: ${error.message}`);
            }
        }
    }
    async getUserById(userId: string): Promise<User | null> {
        try {
          const response = await databases.getDocument(
            db.databaseId,
            db.collections.USERS,
            userId
          );
          return UserSchema.parse(response);
        } catch (error: any) {
          if (error.code === 404) return null;
          throw new Error(`Failed to get user: ${error.message}`);
        }
      }

      async createStory(
        storyData: Omit<Story, "story_id">
      ): Promise<Story> {
        try {
          const validatedData = StorySchema.parse({
            ...storyData,
            story_id: ID.unique(),
          });
    
          const response = await databases.createDocument(
            db.databaseId,
            db.collections.STORIES,
            validatedData.story_id,
            validatedData
          );
    
          return StorySchema.parse(response);
        } catch (error: any) {
          throw new Error(`Failed to create story: ${error.message}`);
        }
      }
      async getActiveStoriesByUser(userId: string): Promise<Story[]> {
        try {
          const response = await databases.listDocuments(
            db.databaseId,
            db.collections.STORIES,
            [
              Query.equal("user_id", userId),
              Query.equal("status", "active"),
            ]
          );
    
          return response.documents.map((doc) => StorySchema.parse(doc));
        } catch (error: any) {
          throw new Error(`Failed to get active stories: ${error.message}`);
        }
      }

      /**
       * Get the starting node of a story
       * @param storyId - The ID of the story
       * @returns The first/starting node of the story
       */
      async getStoryStartNode(storyId: string): Promise<StoryNode> {
        try {
          const response = await databases.listDocuments(
            db.databaseId,
            db.collections.STORY_NODES,
            [
              Query.equal("story_id", storyId),
              Query.equal("is_root", true),
              Query.limit(1)
            ]
          );

          if (response.documents.length === 0) {
            throw new Error(`No starting node found for story ${storyId}`);
          }

          return StoryNodeSchema.parse(response.documents[0]);
        } catch (error: any) {
          throw new Error(`Failed to get story start node: ${error.message}`);
        }
      }

      /**
       * Get the next story node based on current node and choice
       * @param currentNodeId - The ID of the current node
       * @param choiceId - The ID of the selected choice
       * @returns The next story node
       */
      async getNextNode(currentNodeId: string, choiceId: string): Promise<StoryNode> {
        try {
          // First, get the current node to access its choices
          const currentNode = await databases.getDocument(
            db.databaseId,
            db.collections.STORY_NODES,
            currentNodeId
          );

          const parsedCurrentNode = StoryNodeSchema.parse(currentNode);
          
          // Find the selected choice
          const selectedChoice = parsedCurrentNode.choices.find(choice => choice.choice_id === choiceId);
          if (!selectedChoice) {
            throw new Error(`Choice ${choiceId} not found in node ${currentNodeId}`);
          }

          // Get the next node
          const nextNode = await databases.getDocument(
            db.databaseId,
            db.collections.STORY_NODES,
            selectedChoice.next_node_id
          );

          return StoryNodeSchema.parse(nextNode);
        } catch (error: any) {
          throw new Error(`Failed to get next node: ${error.message}`);
        }
      }

      /**
       * Create a new story node
       * @param nodeData - The story node data without auto-generated fields
       * @returns The created story node
       */
      async createStoryNode(
        nodeData: Omit<StoryNode, "node_id">
      ): Promise<StoryNode> {
        try {
          const validatedData = StoryNodeSchema.parse({
            ...nodeData,
            node_id: ID.unique(),
          });

          const response = await databases.createDocument(
            db.databaseId,
            db.collections.STORY_NODES,
            validatedData.node_id,
            validatedData
          );

          return StoryNodeSchema.parse(response);
        } catch (error: any) {
          throw new Error(`Failed to create story node: ${error.message}`);
        }
      }

      /**
       * Get a story node by its ID
       * @param nodeId - The ID of the story node
       * @returns The story node or null if not found
       */
      async getStoryNodeById(nodeId: string): Promise<StoryNode | null> {
        try {
          const response = await databases.getDocument(
            db.databaseId,
            db.collections.STORY_NODES,
            nodeId
          );
          return StoryNodeSchema.parse(response);
        } catch (error: any) {
          if (error.code === 404) return null;
          throw new Error(`Failed to get story node: ${error.message}`);
        }
      }

      /**
       * Get all nodes for a specific story
       * @param storyId - The ID of the story
       * @returns Array of story nodes
       */
      async getStoryNodes(storyId: string): Promise<StoryNode[]> {
        try {
          const response = await databases.listDocuments(
            db.databaseId,
            db.collections.STORY_NODES,
            [Query.equal("story_id", storyId)]
          );

          return response.documents.map((doc) => StoryNodeSchema.parse(doc));
        } catch (error: any) {
          throw new Error(`Failed to get story nodes: ${error.message}`);
        }
      }
}
// Export a single shared instance of the service
export const databaseService = new DatabaseService();